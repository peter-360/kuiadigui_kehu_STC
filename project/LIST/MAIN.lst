C51 COMPILER V9.60.0.0   MAIN                                                              05/27/2020 15:57:04 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\hex\MAIN.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\user\MAIN.C LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\user) DEBUG OBJE
                    -CTEXTEND PRINT(.\LIST\MAIN.lst) TABS(2) OBJECT(..\hex\MAIN.obj)

line level    source

   1          /*                        -- ¶ÉºÓÂìÒÏµç×Ó¹¤×÷ÊÒ --                        */
   2          /*
   3          *   Ëµ    Ã÷: STC8A8KS4A12 DEMO³ÌÐò
   4          *   ¿ª·¢Æ½Ì¨: STC15W408S     
   5          *   ÌÔ±¦Íøµê: 
   6          *
   7          //  ÎÄ¼þÃû£ºmain.c                                                              
   8          //  ËµÃ÷£º¹©¿Í»§²âÊÔÄ£¿éÍ¨ÐÅÊ¹ÓÃ³ÌÐò                                                                  
   9          //  ±àÐ´ÈËÔ±£ºDuhemayi                                                                   
  10          //  ±àÐ´ÈÕÆÚ£º2018-09-16                                                               
  11          //  ³ÌÐòÎ¬»¤£º
  12          //  Î¬»¤¼ÇÂ¼£º
  13          //  °æ    ±¾: V1.0
  14          //                                                          
  15          // ÃâÔðÉùÃ÷£º¸Ã³ÌÐò½öÓÃÓÚÑ§Ï°Óë½»Á÷ 
  16          // (c) Duhemayi Corporation. All rights reserved.     
  17          ******************************************************************************/
  18          #include "config.h"
  19          
  20          
  21          
  22          
  23          
  24          
  25          
  26          void spear_uart_send_datas(uint8* str, uint8 len)
  27          {
  28   1        while(len--)
  29   1        {
  30   2      //    USART_SendData(USART1, *str);
  31   2      //    while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET); 
  32   2      //    str++;
  33   2          UartSend(*str++);
  34   2        }
  35   1      }
  36          
  37          void debug_uart_send_datas(uint8* str, uint8 len)
  38          {
  39   1        UartSend(0xee);
  40   1        while(len--)
  41   1        {
  42   2      //    USART_SendData(USART1, *str);
  43   2      //    while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET); 
  44   2      //    str++;
  45   2          UartSend(*str++);
  46   2        }
  47   1        UartSend(0xff);
  48   1      }
  49          
  50          
  51          
  52          
  53          ///command struct
  54          typedef struct
C51 COMPILER V9.60.0.0   MAIN                                                              05/27/2020 15:57:04 PAGE 2   

  55          {
  56            //uint8_t type;
  57            uint8_t opcode;
  58            
  59            uint8_t board_addr;
  60            uint8_t lock_addr;//-------
  61            uint8_t gu_ding;//---
  62            
  63            uint8_t bcc;
  64          }command1_struct;
  65          
  66          /////start process the data in
  67          
  68          command1_struct m_data;
  69          
  70          
  71          uint8_t ComputXor(uint8_t *InData, uint16_t Len)
  72          {
  73   1        uint8_t Sum = 0;
  74   1        uint16_t i;
  75   1        for(i = 0; i < Len; i++)
  76   1        {
  77   2          Sum ^= InData[i]; 
  78   2        }
  79   1        return Sum;
  80   1      }
  81          
  82          void data_parse()
  83          {
  84   1        uint8_t bcc_temp;
  85   1        uint8_t tx_Buffer[256]={0};        //?????
  86   1        //uint8_t length = 0;             //??
  87   1        uint8_t gpio_level=0;
  88   1        uint8_t grp_level_1;
  89   1        uint8_t grp_level_2;
  90   1        uint8_t grp_level_3;
  91   1        uint8_t board_addr;
  92   1        
  93   1        uint8_t Uart1_Buffer_T[256]={0};        //?????
  94   1        uint8_t Uart1_Rx_T = 0;             //??
  95   1        
  96   1        uint8_t DSW_T_1, DSW_T_2, DSW_T_3, DSW_T_4, DSW_T_5, DSW_T_6 ;
  97   1        
  98   1        //SEGGER_RTT_printf(0, "-parse-Uart1_Rx = %d\n",Uart1_Rx);      //RTT´òÓ¡
  99   1        Uart1_Rx_T = Uart1_Rx - 8;
 100   1        //SEGGER_RTT_printf(0, "-Uart1_Rx_T = %d\n",Uart1_Rx_T);      //RTT´òÓ
 101   1        memcpy(Uart1_Buffer_T,Uart1_Buffer+4,Uart1_Rx_T);
 102   1        
 103   1        DSW_T_1 = ~DSW_1;
 104   1        DSW_T_2 = ~DSW_2;
 105   1        DSW_T_3 = ~DSW_3;
 106   1        DSW_T_4 = ~DSW_4;
 107   1        DSW_T_5 = ~DSW_5;
 108   1        DSW_T_6 = ~DSW_6;
 109   1        board_addr= DSW_T_1 | (DSW_T_2<<1) | (DSW_T_3<<2) | (DSW_T_4<<3) | (DSW_T_5<<4) | (DSW_T_6<<5) ;
 110   1        
 111   1        //UartSend(board_addr);
 112   1        if(board_addr == Uart1_Buffer_T[1])//todo
 113   1        {
 114   2          if(5==Uart1_Rx_T)
 115   2          {
 116   3            m_data.opcode = Uart1_Buffer_T[0];
C51 COMPILER V9.60.0.0   MAIN                                                              05/27/2020 15:57:04 PAGE 3   

 117   3            m_data.board_addr = Uart1_Buffer_T[1];// to do
 118   3            m_data.lock_addr = Uart1_Buffer_T[2];//
 119   3            m_data.gu_ding = Uart1_Buffer_T[3];//
 120   3            m_data.bcc = Uart1_Buffer_T[4];
 121   3      
 122   3            bcc_temp = ComputXor(Uart1_Buffer_T,4);
 123   3            //SEGGER_RTT_printf(0, "bcc_temp = %x\n",bcc_temp);
 124   3            if(bcc_temp == m_data.bcc)
 125   3            {
 126   4              switch(m_data.opcode)
 127   4              {
 128   5                case 0x8A:
 129   5                  //----1------
 130   5                  if(m_data.gu_ding  == 0x11)//process
 131   5                  {
 132   6                    switch(m_data.lock_addr)
 133   6                    {     
 134   7                      case 1:
 135   7                        GO_1=1;           //open
 136   7                        delay_ms(20);  
 137   7                        GO_1=0;           //close
 138   7                        delay_ms(20);  
 139   7                      
 140   7                        GO_1=1;
 141   7                        GI_1=1;
 142   7                      
 143   7                        GO_2=1;
 144   7                        GI_2=1;
 145   7                      
 146   7                        GO_3=1;
 147   7                        GI_3=1;
 148   7      
 149   7                        
 150   7      
 151   7                        
 152   7                        gpio_level = 0x01;
 153   7                        //gpio_level= GI_1;
 154   7                        //SEGGER_RTT_printf(0, "%d:gpio_level = %x\n",m_data.lock_addr,gpio_level);
 155   7                        UartSendStr("\r\n--1--\r\n");
 156   7                        break;
 157   7                      
 158   7                      case 2:
 159   7                        GO_2=1;              //open
 160   7                        delay_ms(20);  
 161   7                        GO_2=0;              //close
 162   7                        delay_ms(20);
 163   7      
 164   7                      
 165   7                        GO_1=0;
 166   7                        GI_1=0;
 167   7                        
 168   7                        GO_2=0;
 169   7                        GI_2=0;
 170   7                      
 171   7                        GO_3=0;
 172   7                        GI_3=0;
 173   7                      
 174   7      
 175   7                        
 176   7                        //gpio_level= GI_2;
 177   7                        gpio_level = 0x01;
 178   7                        //SEGGER_RTT_printf(0, "%d:gpio_level = %x\n",m_data.lock_addr,gpio_level);
C51 COMPILER V9.60.0.0   MAIN                                                              05/27/2020 15:57:04 PAGE 4   

 179   7                        UartSendStr("\r\n--2--\r\n");
 180   7                        break;
 181   7                      
 182   7                      
 183   7                      case 3:
 184   7                        GO_3=0;              //open
 185   7                        delay_ms(20);  
 186   7                        GO_3=1;              //close
 187   7                        delay_ms(20);  
 188   7                        
 189   7      //                  GO_3=1;           //open
 190   7      //                  delay_ms(20);  
 191   7      //                  GO_3=0;           //close
 192   7      //                  delay_ms(20);  
 193   7      
 194   7                        gpio_level = 0x01;
 195   7                        //gpio_level= GI_1;
 196   7                        //SEGGER_RTT_printf(0, "%d:gpio_level = %x\n",m_data.lock_addr,gpio_level);
 197   7                        UartSendStr("\r\n--3--\r\n");
 198   7                        break;
 199   7                      
 200   7                      default:
 201   7                        break;
 202   7      
 203   7                    }
 204   6                    
 205   6                    memcpy(tx_Buffer,"star",4);
 206   6                    tx_Buffer[4]= m_data.opcode;
 207   6                    tx_Buffer[5]= m_data.board_addr;
 208   6                    tx_Buffer[6]= m_data.lock_addr;
 209   6                    
 210   6                    if(0x01 == gpio_level)
 211   6                      tx_Buffer[7]= 0x11;//lock state todo open
 212   6                    else
 213   6                      tx_Buffer[7]= 0x00;//lock state todo close
 214   6                    
 215   6                    bcc_temp = ComputXor(tx_Buffer+4,4);
 216   6                    tx_Buffer[8]= bcc_temp;
 217   6                    memcpy(tx_Buffer+9,"end",3);
 218   6                    
 219   6                    tx_Buffer[12]='\0';
 220   6                    
 221   6                    spear_uart_send_datas(tx_Buffer,12);
 222   6      //              spear_rtt_send_datas(tx_Buffer,12);
 223   6      
 224   6                    //SEGGER_RTT_printf(0, "ok,m_data.opcode=%02x\n",m_data.opcode);
 225   6                  }
 226   5                  else
 227   5                  {
 228   6                    //SEGGER_RTT_printf(0, "error-2,m_data.opcode=%02x\n",m_data.opcode);
 229   6                  }
 230   5                  break;
 231   5                  
 232   5      
 233   5                default:
 234   5                  break;
 235   5              }
 236   4              
 237   4              //SEGGER_RTT_printf(0, "m_data.bcc = %x\n",m_data.bcc);
 238   4            }
 239   3            else
 240   3            {
C51 COMPILER V9.60.0.0   MAIN                                                              05/27/2020 15:57:04 PAGE 5   

 241   4              //SEGGER_RTT_printf(0, "error-1-m_data.bcc = %x\n",m_data.bcc);
 242   4            }
 243   3            
 244   3          }
 245   2          
 246   2          
 247   2          
 248   2        }
 249   1      
 250   1      }
*** WARNING C280 IN LINE 88 OF ..\user\MAIN.C: 'grp_level_1': unreferenced local variable
*** WARNING C280 IN LINE 89 OF ..\user\MAIN.C: 'grp_level_2': unreferenced local variable
*** WARNING C280 IN LINE 90 OF ..\user\MAIN.C: 'grp_level_3': unreferenced local variable
 251          
 252          
 253          
 254          
 255          /******************************************************************************/
 256          // º¯ÊýÃû³Æ£ºmain 
 257          // ÊäÈë²ÎÊý£º 
 258          // Êä³ö²ÎÊý£º 
 259          // º¯Êý¹¦ÄÜ£º 
 260          /******************************************************************************/
 261          void main(void)
 262          {
 263   1      //  uint16 ADC_RES;
 264   1          
 265   1        Uart1Init();
 266   1      //  Timer4_Init();
 267   1        Timer0_Init();
 268   1        ES = 1;
 269   1        EA = 1;
 270   1      //  Read_ID_fromROM();  
 271   1      ////  ADC_Init();
 272   1      //  PWM0_INIT();
 273   1      //  PCA_INIT();
 274   1        
 275   1        
 276   1        RS485_RX_EN();
 277   1      
 278   1        UartSendStr("Uart Test 1!\r\n");
 279   1        while(1)
 280   1        {
 281   2          if((1== packerflag))
 282   2          {
 283   3            RS485_TX_EN();
 284   3      
 285   3      //      SEGGER_RTT_printf(0, "\n");
 286   3      //      SEGGER_RTT_printf(0, "-main-Uart1_Rx = %d\n",Uart1_Rx);      //RTT´òÓ¡
 287   3      //      SEGGER_RTT_printf(0, "---rcv-datas---"); 
 288   3            //spear_rtt_send_datas(Uart1_Buffer,Uart1_Rx);
 289   3            
 290   3            //spear_uart_send_datas(Uart1_Buffer,Uart1_Rx); //debug
 291   3      
 292   3      
 293   3            data_parse();
 294   3            RS485_RX_EN();
 295   3            
 296   3            memset(Uart1_Buffer,0,13);//max =4+5+4 =13
 297   3            Uart1_Rx   = 0 ;
 298   3            packerflag = 0;
 299   3            //Uart1_index_flag_end =0;
C51 COMPILER V9.60.0.0   MAIN                                                              05/27/2020 15:57:04 PAGE 6   

 300   3          }
 301   2          
 302   2        
 303   2          
 304   2        }
 305   1      }
 306          
 307          
 308          
 309          
 310          
 311          //    LED1 = 0;
 312          ////    GO_1 = 0;
 313          //    Delay100ms();
 314          //    Delay100ms();
 315          //    Delay100ms();
 316          //    Delay100ms();
 317          //    Delay100ms();
 318          //    LED1 = 1;
 319          ////    GO_1 =1;
 320          //    Delay100ms();
 321          //    Delay100ms();
 322          //    Delay100ms();
 323          //    Delay100ms();
 324          //    Delay100ms();
 325          
 326          //    ADC_RES = Get_ADC_RES();
 327          //    UartSend(ADC_RES);
 328          //    ADC_RES = ADC_RES>>8;
 329          //    UartSend(ADC_RES>>8);
 330              
 331          
 332          //    UartSend(length);
 333          //    UartSend(length>>8);
 334          //    UartSend(length>>16);
 335          //    UartSend(length>>24);
 336          //    RS485_RX_EN();
 337          //    UartSendStr("Uart Test 2 -RX!\r\n");
 338          //    delay_ms(4000);
 339          //    
 340          //    RS485_TX_EN();
 341          //    UartSendStr("Uart Test 3 -TX!\r\n");//no xianshi
 342          //    delay_ms(2100);


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    853    ----
   CONSTANT SIZE    =    566    ----
   XDATA SIZE       =      5     536
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
